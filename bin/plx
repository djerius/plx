#!/usr/bin/env perl

package Perl::Layout::Executor;

use strict;
use warnings;
use File::Spec;
use File::Basename ();
use Cwd ();
use lib ();
use Config;
use File::Which ();
use List::Util ();

BEGIN { our %orig_env = %ENV }
use local::lib '--deactivate-all';
BEGIN { delete @ENV{grep /^PERL/, keys %ENV} }
no lib @Config{qw(sitearch sitelibexp)};

my $self = do {
  package Perl::Layout::Executor::_self;
  sub self { package DB; () = caller(2); $DB::args[0] }
  use overload '%{}' => sub { self }, fallback => 1;
  sub AUTOLOAD {
    my ($meth) = (our $AUTOLOAD =~ /([^:]+)$/);
    self->$meth(@_[1..$#_]);
  }
  bless([], __PACKAGE__);
};

sub barf { die "$_[0]\n" }

sub stderr { warn "$_[0]\n" }

sub say { print "$_[0]\n" }

sub new {
  my $class = shift;
  bless @_ ? @_ > 1 ? {@_} : {%{$_[0]}} : {}, ref $class || $class;
}

sub layout_base_dir {
  $self->{layout_base_dir} //= $self->_build_layout_base_dir
}
sub layout_perl {
  $self->{layout_perl} //= $self->_build_layout_perl
}

sub _build_layout_base_dir {
  # we will walk upwards later (we don't check if the directory exists
  # because setup actions may use this path)
  return Cwd::getcwd();
}

sub _build_layout_perl {
  my $perl_bin = $self->read_config_entry('perl');
  unless ($perl_bin) {
    my $perl_spec = $self->read_config_entry('perl.spec');
    barf "No perl and no perl.spec in config" unless $perl_spec;
    $self->run_config_perl_set($perl_spec);
    $perl_bin = $self->read_config_entry('perl');
    barf "Rehydration of perl from perl.spec failed" unless $perl_bin;
  }
  barf "perl binary ${perl_bin} not executable" unless -x $perl_bin;
  return $perl_bin;
}

sub layout_libspec_config {
  opendir my($dh), $self->layout_config_dir('libs');
  [ grep $_->[1],
      map [ $_, $self->read_config_entry([ libs => $_ ]) ],
        sort readdir($dh) ];
}

sub layout_lib_specs {
  my $base_dir = $self->layout_base_dir;
  local *_ = sub { Cwd::realpath(File::Spec->rel2abs(shift, $base_dir)) };
  [ map [ ($_->[0] =~ /\.(.*)$/), _($_->[1]) ],
      @{$self->layout_libspec_config} ];
}

sub layout_file {
  my ($self, @path) = @_;
  File::Spec->catfile($self->layout_base_dir, @path);
}

sub layout_dir {
  my ($self, @path) = @_;
  File::Spec->catdir($self->layout_base_dir, @path);
}

sub ensure_layout_config_dir {
  barf ".plx directory does not exist"
    unless -d $self->layout_dir('.plx');
}

sub layout_config_file { shift->layout_file('.plx', @_) }
sub layout_config_dir { shift->layout_dir('.plx', @_) }

sub write_config_entry {
  my ($self, $path, $value) = @_;
  my $file = $self->layout_config_file(ref($path) ? @$path : $path);
  open my $wfh, '>', $file or die "Couldn't open ${file}: $!";
  print $wfh "${value}\n";
}

sub clear_config_entry {
  my ($self, $path) = @_;
  my $file = $self->layout_config_file(ref($path) ? @$path : $path);
  unlink($file) or barf "Failed to unlink ${file}: $!" if -e $file;
}

sub read_config_entry {
  my ($self, $path) = @_;
  my $file = $self->layout_config_file(ref($path) ? @$path : $path);
  return undef unless -f $file;
  open my $rfh, '<', $file or die "Couldn't open ${file}: $!";
  chomp(my $value = <$rfh>);
  return $value;
}

sub slurp_command {
  my ($self, @cmd) = @_;
  open my $slurp_fh, '-|', @cmd
    or barf "Failed to start command (".join(' ', @cmd)."): $!";
  chomp(my @slurp = <$slurp_fh>);
  return @slurp;
}

sub prepend_env {
  my ($self, $env, @parts) = @_;
  $ENV{$env} = join(':', @parts, $ENV{$env}||());
}

sub setup_env_for_ll {
  my ($self, $path) = @_;
  local::lib->import($path);
}

sub setup_env_for_dir {
  my ($self, $path) = @_;
  $self->prepend_env(PERL5LIB => $path) if -d $path;
}

sub setup_env {
  my $perl_dirname = File::Basename::dirname($self->layout_perl);
  unless (grep $_ eq $perl_dirname, split ':', $ENV{PATH}) {
    $self->prepend_env(PATH => $perl_dirname);
  }
  foreach my $lib_spec (@{$self->layout_lib_specs}) {
    my ($type, $path) = @$lib_spec;
    $self->${\"setup_env_for_${type}"}($path);
  }
  my ($site_libs) = $self->slurp_command(
    $self->layout_perl, '-MConfig', '-e',
      'print join(",", @Config{qw(sitearch sitelibexp)})'
  );
  $ENV{PERL5OPT} = '-M-lib='.$site_libs;
  return;
}

sub run_action_init {
  my ($self, $perl) = @_;
  unless (-d (my $dir = $self->layout_dir('.plx'))) {
    mkdir($dir) or barf "Couldn't create ${dir}: $!";
  }
  $self->run_config_perl_set($perl||'perl');
  $self->write_config_entry(format => 1);
  my $libspec_dir = $self->layout_config_dir('libs');
  mkdir($libspec_dir) unless -d $libspec_dir;
  $self->run_config_libspec_add(@$_) for (
    [ '25local.ll' => 'local' ],
    [ '50devel.ll' => 'devel' ],
    [ '75lib.dir' => 'lib' ],
  );
}

sub run_action_cmd {
  my ($self, $cmd, @args) = @_;

  if ($cmd eq 'perl') {
    return $self->run_action_perl(@args);
  }

  if ($cmd =~ m{/} or $cmd =~ m{^-}) {
    return $self->run_action_perl($cmd, @args);
  }

  if (-f $self->layout_file(dev => $cmd)) {
    return $self->run_action_dev($cmd, @args);
  }

  if (-f $self->layout_file(bin => $cmd)) {
    return $self->run_action_bin($cmd, @args);
  }

  $self->run_action_exec($cmd, @args);
}

sub run_action_perl {
  my ($self, @call) = @_;
  return $self->run_config_perl_show unless @call;
  $self->run_action_exec($self->layout_perl, @call);
}

sub run_action_dev {
  my ($self, $cmd, @args) = @_;
  $self->run_action_perl($self->layout_file(dev => $cmd), @args);
}

sub run_action_bin {
  my ($self, $cmd, @args) = @_;
  $self->run_action_perl($self->layout_file(bin => $cmd), @args);
}

sub run_action_exec {
  my ($self, @exec) = @_;
  $self->setup_env;
  no warnings 'exec';
  exec(@exec) or barf "exec of (".join(' ', @exec).") failed: $!";
}

sub run_action_cpanm {
  my ($self, @args) = @_;
  my $cpanm = do {
    local %ENV = our %orig_env;
    barf "Couldn't find cpanm in \$PATH"
      unless my $cpanm = File::Which::which('cpanm');
    $cpanm;
  };
  unless (@args and $args[0] =~ /^-[lL]/) {
    barf "--cpanm args must start with -l or -L to specify target local::lib";
  }
  $self->setup_env;
  $self->run_action_perl($cpanm, @args);
}

sub run_action_config {
  my ($self, $config, @args) = @_;
  barf "No config name provided" unless $config;
  barf "Unknown config key ${config}"
    unless my $show = $self->can("run_config_${config}_show");
  return $self->$show unless @args;
  my ($subcmd, @rest) = @args;
  barf "Invalid subcommand ${subcmd} for config key ${config}"
    unless my $code = $self->can("run_config_${config}_${subcmd}");
  return $self->$code(@rest);
}

sub run_config_perl_show { say $self->layout_perl }

sub resolve_perl_via_perlbrew {
  my ($self, $perl) = @_;
  stderr "Resolving perl '${perl}' via perlbrew";
  local %ENV = our %orig_env;
  barf "Couldn't find perlbrew in \$PATH"
    unless my $perlbrew = File::Which::which('perlbrew');
  my @list = $self->slurp_command($perlbrew, 'list');
  barf join(
    "\n", "No such perlbrew perl '${perl}', choose from:\n", @list, ''
  ) unless grep $_ eq $perl, map /(\S+)/, @list;
  my ($perl_path) = $self->slurp_command(
    $perlbrew, qw(exec --with), $perl, qw(perl -e), 'print $^X'
  );
  return $perl_path;
}

sub run_config_perl_set {
  my ($self, $new_perl) = @_;
  barf "plx --config perl set <perl>" unless $new_perl;
  my $perl_spec = $new_perl;
  unless ($new_perl =~ m{/}) {
    $new_perl = "perl${new_perl}" if $new_perl =~ /^5/;
    $new_perl =~ s/perl-5/perl5/; # perlbrew name to perl binary
    require File::Which;
    stderr "Resolving perl '${new_perl}' via PATH";
    if (my $resolved = File::Which::which($new_perl)) {
      $new_perl = $resolved;
    } else {
      $new_perl = s/^perl5/perl-5/; # perl binary to perlbrew name
      $new_perl = $self->resolve_perl_via_perlbrew($new_perl);
    }
  }
  barf "Not executable: $new_perl" unless -x $new_perl;
  $self->write_config_entry('perl.spec' => $perl_spec);
  $self->write_config_entry(perl => $new_perl);
}

sub run_config_libspec_show {
  my @ent = @{$self->layout_libspec_config};
  my $max = List::Util::max(map length($_->[0]), @ent);
  say sprintf("%-${max}s  %s", @$_) for @ent;
}

sub run_config_libspec_add {
  my ($self, $name, $path) = @_;
  barf "plx --config libspec add <name> <path>" unless $name and $path;
  $self->write_config_entry([ libs => $name ], $path);
}

sub run_config_libspec_del {
  my ($self, $name) = @_;
  barf "plx --config libspec add <name>" unless $name;
  $self->clear_config_entry([ libs => $name ]);
}

sub show_env {
  my ($self, $env) = @_;
  local $ENV{$env} = '';
  $self->setup_env;
  say $_ for split ':', $ENV{$env};
}

sub run_action_libs { $self->show_env('PERL5LIB') }

sub run_action_paths { $self->show_env('PATH') }

sub run_action_help {
  require Pod::Usage;
  Pod::Usage::pod2usage();
}

sub run {
  my ($self, $cmd, @args) = @_;
  $self->run_action_help unless $cmd;
  $self->ensure_layout_config_dir unless $cmd eq '--init';
  if ($cmd =~ s/^--//) {
    my $method = join('_', 'run_action', split '-', $cmd);
    if (my $code = $self->can($method)) {
      return $self->$code(@args);
    }
    barf "No command for ${cmd}";
  }
  return $self->run_action_cmd($cmd, @args);
}

caller() ? 1 : __PACKAGE__->new->run(@ARGV);

__END__

=head1 NAME

plx - Perl Layout Executor

=head1 USAGE

  plx --help                             # This output

  plx --perl                             # Show perl binary
  plx --libs                             # Show $PERL5LIB entries
  plx --paths                            # Show additional $PATH entries

  plx --config perl                      # Show perl binary
  plx --config perl show                 # Show perl binary
  plx --config perl set /path/to/perl    # Select exact perl binary
  plx --config perl set perl-5.xx.y      # Select perl via $PATH or perlbrew

  plx --config libspec                   # Show lib specifications
  plx --config libspec show              # Show lib specifications
  plx --config libspec add <name> <path> # Add lib specification
  plx --config libspec del <name> <path> # Delete lib specification

  plx --exec <cmd> <args>                # exec()s with env vars set
  plx --perl <args>                      # Run perl with args
  plx --bin <script> <args>              # Run script from bin/
  plx --dev <script> <args>              # Run script from dev/
  plx --cpanm <args>                     # Run fatpacked cpanm

  plx --cmd <cmd> <args>                 # DWIM command:
  
    cmd = perl           -> --perl <args>
    cmd = -<flag>        -> --perl -<flag> <args>
    cmd = some/file      -> --perl some/file <args>
    cmd = ./file         -> --perl ./file <args>
    cmd = name ->
      exists dev/<name>  -> --dev <name> <args>
      exists bin/<name>  -> --bin <name> <args>
      else               -> --exec <name> <args>
  
  plx <something> <args>                 # equivalent to --cmd so:
 
  plx perl <args>                        # runs perl
  plx -E '...'                           # runs perl 
  plx script-in-dev <args>               # runs script in dev/
  plx script-in-bin <args>               # runs script in bin/
  plx script/in/cwd <args>               # runs script in cwd
  plx program <args>                     # runs program from plx $PATH

=head1 ACTIONS

=head2 --help

Prints out the usage information (i.e. the L</SYNOPSIS>) for plx.

=head2 --perl

Without arguments: prints the perl binary that plx will use to execute things.

With arguments: Executes perl with those arguments.

=head2 --config perl set

If the argument contains a / character, it is assumed to be a perl binary
and C<plx> checks that it's executable then records it as the current perl.

If not, C<plx> attempts to resolve it as a L<perlbrew> binary name and if
successful records that binary as the current perl.

=head2 --config perl clear

Clears the C<plx> perl binary setting and reverts the config to whatever is
available in C<$PATH>.

=head2 --libs

Prints the directories that will be added to C<PERL5LIB>, one per line.

=head2 --paths

Prints the directories that will be added to C<PATH>, one per line.

=head2 --cpanm

Calls a per-C<plx>-config cpanm, which is fetched from miyagawa's github on
demand. Intended for bootstrapping or for minimising installed modules.

=head2 script

If C<plx> is passed a plain name and that exists as a filename within C<dev/>
or C<bin/> then the file will be called using C<perl>.

=head2 ./file

if C<plx> is passed a name containing a C</> character then that filename is
called using C<perl>.

=head2 command

If C<plx> is passed a name without a C</> character that does not exist as an
L</script> then it calls it as a normal command name, respecting the C<$PATH>
as set up by the layout.

=cut
