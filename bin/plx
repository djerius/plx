#!/usr/bin/env perl

use 5.010;

package Perl::Layout::Executor;

use Config;

BEGIN {
  our %orig_env = %ENV;
  if ($ENV{PERL_LOCAL_LIB_ROOT}) {
    eval { require local::lib; local::lib->import('--deactivate-all') };
  }
  delete @ENV{grep /^PERL/, keys %ENV};
  my @inc = @Config{qw(vendorarch vendorlibexp archlibexp privlibexp)};
  @INC = @inc;
  package Perl::Layout::Executor::_self;
  use overload
    '%{}' => sub {
      my $self = do { package DB; my @meh = caller(1); $DB::args[0] };
      $self;
    },
    fallback => 1,
  ;
  sub AUTOLOAD {
    my ($meth) = (our $AUTOLOAD =~ /([^:]+)$/);
    shift;
    my $self = do { package DB; my @meh = caller(1); $DB::args[0] };
    $self->$meth(@_);
  }
}

use strict;
use warnings;
use feature 'say';
use File::Spec;
use File::Basename ();
use Cwd ();
use lib ();

sub barf { die "$_[0]\n" }

sub stderr { warn "$_[0]\n" }

my $self = bless([], 'Perl::Layout::Executor::_self');

my $run_from = Cwd::getcwd;

my $fs = 'File::Spec';

sub new {
  my $class = shift;
  bless @_ ? @_ > 1 ? {@_} : {%{$self}} : {}, ref $class || $class;
}

sub layout_base_dir {
  $self->{layout_base_dir} //= $self->_build_layout_base_dir
}
sub layout_conf_dir {
  $self->{layout_conf_dir} //= $self->_build_layout_conf_dir
}
sub layout_perl {
  $self->{layout_perl} //= $self->_build_layout_perl
}
sub layout_local_libs {
  $self->{layout_local_libs} //= $self->_build_layout_local_libs
}
sub layout_extra_lib_dirs {
  $self->{layout_extra_lib_dirs} //= $self->_build_layout_extra_lib_dirs
}
sub layout_all_lib_dirs {
  $self->{layout_all_lib_dirs} //= $self->_build_layout_all_lib_dirs
}

sub _build_layout_base_dir {
  # we will walk upwards later
  if (grep -d $_, map $fs->catdir($run_from, $_), qw(.git .plx)) {
    return $run_from;
  }
  return '';
}

sub _build_layout_conf_dir {
  return '' unless my $base_dir = $self->layout_base_dir;
  my $conf_dir = $fs->catdir($base_dir, '.plx');
  return -d $conf_dir ? $conf_dir : '';
}

sub _build_layout_perl {
  return $^X unless my $conf_dir = $self->layout_conf_dir;
  my $perl_link = $fs->catfile($conf_dir, 'perl');
  return -l $perl_link ? readlink($perl_link) : $^X;
}

sub _build_layout_local_libs {
  return [] unless my $base_dir = $self->layout_base_dir;
  return [ grep -d $_, map $fs->catdir($base_dir, $_), qw(local devel) ];
}

sub _build_layout_extra_lib_dirs {
  return [] unless my $base_dir = $self->layout_base_dir;
  return [ grep -d $_, $fs->catdir($base_dir, 'lib') ];
}

sub _build_layout_all_lib_dirs {
  return [
    @{$self->layout_extra_lib_dirs},
    (map $fs->catdir($_, qw(lib perl5)),
      @{$self->layout_local_libs}),
  ]
}

sub slurp_command {
  my ($self, @cmd) = @_;
  open my $site_fh, '-|', @cmd
    or barf "Failed to start command (".join(' ', @cmd)."): $!";
  my @slurp = <$site_fh>;
  return @slurp;
}

sub setup_env {
  {
    my $perl_dirname = File::Basename::dirname($self->layout_perl);
    unless (grep $_ eq $perl_dirname, split ':', $ENV{PATH}) {
      $ENV{PATH} = join(':', $perl_dirname, $ENV{PATH}||());
    }
  }
  {
    my @lib_dirs = do {
      if (eval { require local::lib; 1 }) {
        local::lib->import($_) for @{$self->layout_local_libs};
        @{$self->layout_extra_lib_dirs};
      } else {
        @{$self->layout_all_lib_dirs};
      }
    };
    $ENV{PERL5LIB} = join(':', @lib_dirs, $ENV{PERL5LIB}||());
  }
  {
    my ($site_libs) = $self->slurp_command(
      $self->layout_perl, '-MConfig', '-e',
        'print join(",", @Config{qw(sitearch sitelibexp)})'
    );
    $ENV{PERL5OPT} = '-M-lib='.$site_libs;
  }
  return;
}

sub exec_file {
  my ($self, $cmd, @args) = @_;
  my @exec = @args;
  if ($cmd eq 'perl') {
    unshift @exec, $self->layout_perl;
  } elsif ($cmd =~ m{/} or $cmd =~ m{^-}) {
    unshift @exec, $self->layout_perl, $cmd;
  } elsif (
    -f (my $bin_file = $fs->catfile($self->layout_base_dir, 'bin', $cmd))
  ) {
    unshift @exec, $self->layout_perl, $bin_file;
  } else {
    unshift @exec, $cmd;
  }
  $self->setup_env;
  no warnings 'exec';
  exec(@exec) or barf "exec of (".join(' ', @exec).") failed: $!";
}

sub run_command_cpanm {
  my ($self, @args) = @_;
  $self->ensure_conf_dir;
  my $cpanm = $fs->catfile($self->layout_conf_dir, 'cpanm');
  unless (-f $cpanm) {
    require File::Fetch;
    my $fetch = File::Fetch->new(uri => 'http://raw.githubusercontent.com/miyagawa/cpanminus/devel/App-cpanminus/cpanm');
    no warnings 'once';
    local $File::Fetch::BLACKLIST = [ qw(LWP HTTP::Tiny) ];
    $fetch->fetch(to => $self->layout_conf_dir);
  }
  $self->setup_env;
  $self->exec_file($cpanm, @args);
}

sub run_command_perl {
  say $self->layout_perl;
}

sub ensure_conf_dir {
  unless (-d (my $dir = $fs->catdir($run_from, '.plx'))) {
    mkdir($dir) or barf "Couldn't create ${dir}: $!";
  }
}

sub run_command_set_perl {
  my ($self, $new_perl) = @_;
  barf "plx --set-perl /path/to/some/bin/perl" unless $new_perl;
  unless ($new_perl =~ m{/}) {
    stderr "Resolving perl ${new_perl} via perlbrew";
    require File::Which;
    local %ENV = our %orig_env;
    barf "Couldn't find perlbrew in \$PATH"
      unless my $perlbrew = File::Which::which('perlbrew');
    my @perls = map /(\S+)/, $self->slurp_command($perlbrew, 'list');
    barf "No such perlbrew perl ${new_perl}"
      unless grep $_ eq $new_perl, @perls;
    ($new_perl) = $self->slurp_command(
      $perlbrew, qw(exec --with), $new_perl, qw(perl -e), 'print $^X'
    );
    chomp $new_perl;
  }
  barf "Not executable: $new_perl" unless -x $new_perl;
  $self->ensure_conf_dir;
  my $perl_link = $fs->catfile($self->layout_conf_dir, 'perl');
  if (-e $perl_link) {
    unlink($perl_link) or barf "Couldn't unlink ${perl_link}: $!";
  }
  symlink($new_perl, $perl_link)
    or barf "Couldn't link ${new_perl} to ${perl_link}: $!";
}

sub run_command_clear_perl {
  return unless my $conf_dir = $self->layout_conf_dir;
  return unless -e (my $perl_link = $fs->catfile($conf_dir, 'perl'));
  unlink($perl_link) or barf "Couldn't unlink ${perl_link}: $!";
}

sub run_command_libs {
  say for @{$self->layout_all_lib_dirs};
}

sub run_command_paths {
  local $ENV{PATH} = '';
  $self->setup_env;
  say for split ':', $ENV{PATH};
}

sub run_command_help {
  require Pod::Usage;
  Pod::Usage::pod2usage();
}

sub run {
  my ($self, $cmd, @args) = @_;
  $self->run_command_help unless $cmd;
  if ($cmd =~ s/^--//) {
    my $method = join('_', 'run_command', split '-', $cmd);
    if (my $code = $self->can($method)) {
      return $self->$code(@args);
    }
    barf "No command for ${cmd}";
  }
  return $self->exec_file($cmd, @args);
}

caller() ? 1 : __PACKAGE__->new->run(@ARGV);

__END__

=head1 NAME

plx - Perl Layout Executor

=head1 SYNOPSIS

  plx --help                             # This output
  plx --perl                             # Which perl will plx exec
  plx --set-perl /path/to/some/bin/perl  # Set perl binary
  plx --set-perl perl-5.xx.y             # Set perl binary to a perlbrew perl
  plx --clear-perl                       # Revert to system perl
  plx --libs                             # Show $PERL5LIB entries
  plx --paths                            # Show additional $PATH entries
  plx --cpanm <args>                     # Run fatpacked cpanm to bootstrap
  plx command arg1 arg2                  # Execute command from $PATH
  plx script arg1 arg2                   # Run script from bin/
  plx ./file arg1 arg2                   # Run file from $PWD

=head1 COMMANDS

=head2 --help

Prints out the usage information (i.e. the L</SYNOPSIS>) for plx.

=head2 --perl

Prints the perl binary that plx will use to execute things

=head2 --set-perl

If the argument contains a / character, it is assumed to be a perl binary
and C<plx> checks that it's executable then records it as the current perl.

If not, C<plx> attempts to resolve it as a L<perlbrew> binary name and if
successful records that binary as the current perl.

=head2 --clear-perl

Clears the C<plx> perl binary setting and reverts the config to whatever is
available in C<$PATH>.

=head2 --libs

Prints the directories that will be added to C<PERL5LIB>, one per line.

=head2 --paths

Prints the directories that will be added to C<PATH>, one per line.

=head2 --cpanm

Calls a per-C<plx>-config cpanm, which is fetched from miyagawa's github on
demand. Intended for bootstrapping or for minimising installed modules.

=head2 script

If C<plx> is passed a plain name and that exists as a filename within C<bin/>
then the file will be called using C<perl>.

=head2 ./file

if C<plx> is passed a name containing a C</> character then that filename is
called using C<perl>.

=head2 command

If C<plx> is passed a name without a C</> character that does not exist in
C<bin/> then it calls it as a normal command name, respecting the C<$PATH>
as set up by the layout.

=cut
