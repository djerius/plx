#!/usr/bin/env perl

package Perl::Layout::Executor;

use strict;
use warnings;
use File::Spec;
use File::Basename ();
use Cwd ();
use lib ();
use Config;
use File::Which ();
use List::Util ();

BEGIN { our %orig_env = %ENV }
use local::lib '--deactivate-all';
BEGIN { delete @ENV{grep /^PERL/, keys %ENV} }
no lib @Config{qw(sitearch sitelibexp)};

BEGIN {
  package Perl::Layout::Executor::_self;
  use overload
    '%{}' => sub {
      my $self = do { package DB; my @meh = caller(1); $DB::args[0] };
      $self;
    },
    fallback => 1,
  ;
  sub AUTOLOAD {
    my ($meth) = (our $AUTOLOAD =~ /([^:]+)$/);
    shift;
    my $self = do { package DB; my @meh = caller(1); $DB::args[0] };
    $self->$meth(@_);
  }
}

sub barf { die "$_[0]\n" }

sub stderr { warn "$_[0]\n" }

sub say { print "$_[0]\n" }

my $self = bless([], 'Perl::Layout::Executor::_self');

my $fs = 'File::Spec';

sub new {
  my $class = shift;
  bless @_ ? @_ > 1 ? {@_} : {%{$_[0]}} : {}, ref $class || $class;
}

sub layout_base_dir {
  $self->{layout_base_dir} //= $self->_build_layout_base_dir
}
sub layout_conf_dir {
  $self->{layout_conf_dir} //= $self->_build_layout_conf_dir
}
sub layout_perl {
  $self->{layout_perl} //= $self->_build_layout_perl
}
sub layout_libspec_dir {
  $self->{layout_libspec_dir} //= $self->_build_layout_libspec_dir
}
sub layout_libspec_config {
  $self->{layout_libspec_config} //= $self->_build_layout_libspec_config
}
sub layout_lib_specs {
  $self->{layout_lib_specs} //= $self->_build_layout_lib_specs
}

sub _build_layout_base_dir {
  # we will walk upwards later (we don't check if the directory exists
  # because setup actions may use this path)
  return Cwd::getcwd();
}

sub _build_layout_conf_dir {
  return '' unless my $base_dir = $self->layout_base_dir;
  my $conf_dir = $fs->catdir($base_dir, '.plx');
  barf ".plx directory does not exist" unless -d $conf_dir;
  return $conf_dir;
}

sub _build_layout_perl {
  return $^X unless my $conf_dir = $self->layout_conf_dir;
  my $perl_link = $fs->catfile($conf_dir, 'perl');
  barf ".plx/perl symlink does not exist" unless -l $perl_link;
  my $perl_bin = readlink($perl_link);
  barf "perl binary ${perl_bin} not executable" unless -x $perl_bin;
  return $perl_bin;
}

sub _build_layout_libspec_dir {
  $fs->catdir($self->layout_conf_dir, 'libs');
}

sub _build_layout_libspec_config {
  my $libspec_dir = $self->layout_libspec_dir;
  [
    map {
      [ $_, readlink($fs->catfile($libspec_dir, $_)) ]
    } do {
      opendir my($dh), $libspec_dir;
      my @ent = readdir($dh);
      grep -l $fs->catfile($libspec_dir, $_), sort @ent;
    }
  ]
}

sub _build_layout_lib_specs {
  my $base_dir = $self->layout_base_dir;
  [
    map { [ $_->[0] =~ /\.(.*)$/, $fs->rel2abs($_->[1], $base_dir) ] }
      @{$self->layout_libspec_config}
  ]
}

sub slurp_command {
  my ($self, @cmd) = @_;
  open my $slurp_fh, '-|', @cmd
    or barf "Failed to start command (".join(' ', @cmd)."): $!";
  my @slurp = <$slurp_fh>;
  return @slurp;
}

sub prepend_env {
  my ($self, $env, @parts) = @_;
  $ENV{$env} = join(':', @parts, $ENV{$env}||());
}

sub setup_env_for_ll {
  my ($self, $path) = @_;
  local::lib->import($path);
}

sub setup_env_for_dir {
  my ($self, $path) = @_;
  $self->prepend_env(PERL5LIB => $path) if -d $path;
}

sub setup_env {
  {
    my $perl_dirname = File::Basename::dirname($self->layout_perl);
    unless (grep $_ eq $perl_dirname, split ':', $ENV{PATH}) {
      $self->prepend_env(PATH => $perl_dirname);
    }
  }
  foreach my $lib_spec (@{$self->layout_lib_specs}) {
    my ($type, $path) = @$lib_spec;
    $self->${\"setup_env_for_${type}"}($path);
  }
  {
    my ($site_libs) = $self->slurp_command(
      $self->layout_perl, '-MConfig', '-e',
        'print join(",", @Config{qw(sitearch sitelibexp)})'
    );
    $ENV{PERL5OPT} = '-M-lib='.$site_libs;
  }
  return;
}

sub run_action_init {
  my ($self, $perl) = @_;
  $self->run_config_perl_set($perl||'perl');
  my $libspec_dir = $self->layout_libspec_dir;
  mkdir($libspec_dir) unless -d $libspec_dir;
  $self->run_config_libspec_add(@$_) for (
    [ '25local.ll' => 'local' ],
    [ '50devel.ll' => 'devel' ],
    [ '75lib.dir' => 'lib' ],
  );
}

sub run_action_cmd {
  my ($self, $cmd, @args) = @_;

  if ($cmd eq 'perl') {
    return $self->run_action_perl(@args);
  }

  if ($cmd =~ m{/} or $cmd =~ m{^-}) {
    return $self->run_action_perl($cmd, @args);
  }

  if (-f $fs->catfile($self->layout_base_dir, 'dev', $cmd)) {
    return $self->run_action_dev($cmd, @args);
  }

  if (-f $fs->catfile($self->layout_base_dir, 'bin', $cmd)) {
    return $self->run_action_bin($cmd, @args);
  }

  $self->run_action_exec($cmd, @args);
}

sub run_action_perl {
  my ($self, @call) = @_;
  return $self->run_config_perl_show unless (@call);
  $self->run_action_exec($self->layout_perl, @call);
}

sub run_action_dev {
  my ($self, $cmd, @args) = @_;
  my $file = $fs->catfile($self->layout_base_dir, 'dev', $cmd);
  $self->run_action_perl($file, @args);
}

sub run_action_bin {
  my ($self, $cmd, @args) = @_;
  my $file = $fs->catfile($self->layout_base_dir, 'bin', $cmd);
  $self->run_action_perl($file, @args);
}

sub run_action_exec {
  my ($self, @exec) = @_;
  $self->setup_env;
  no warnings 'exec';
  exec(@exec) or barf "exec of (".join(' ', @exec).") failed: $!";
}

sub fetch_cpanm {
  require File::Fetch;
  my $fetch = File::Fetch->new(uri => 'http://raw.githubusercontent.com/miyagawa/cpanminus/devel/App-cpanminus/cpanm');
  no warnings 'once';
  local $File::Fetch::BLACKLIST = [ qw(LWP HTTP::Tiny) ];
  $fetch->fetch(to => $self->layout_conf_dir);
  return;
}

sub run_action_cpanm {
  my ($self, @args) = @_;
  $self->ensure_conf_dir;
  my $cpanm = $fs->catfile($self->layout_conf_dir, 'cpanm');
  if (@args and $args[0] eq '--self-upgrade') {
    if (-f $cpanm) {
      unlink($cpanm) or barf "Failed to unlink old ${cpanm}: $!";
    }
    return $self->fetch_cpanm;
  }
  unless (@args and $args[0] =~ /^-[lL]/) {
    barf "--cpanm args must start with -l or -L to specify target local::lib";
  }
  unless (-f $cpanm) {
    $self->fetch_cpanm;
  }
  $self->setup_env;
  $self->run_action_cmd($cpanm, @args);
}

sub ensure_conf_dir {
  unless (-d (my $dir = $fs->catdir($self->layout_base_dir, '.plx'))) {
    mkdir($dir) or barf "Couldn't create ${dir}: $!";
  }
}

sub run_action_config {
  my ($self, $config, @args) = @_;
  barf "No config name provided" unless $config;
  barf "Unknown config key ${config}"
    unless my $show = $self->can("run_config_${config}_show");
  return $self->$show unless @args;
  my ($subcmd, @rest) = @args;
  barf "Invalid subcommand ${subcmd} for config key ${config}"
    unless my $code = $self->can("run_config_${config}_${subcmd}");
  return $self->$code(@rest);
}

sub run_config_perl_show {
  say $self->layout_perl;
}

sub ensure_link {
  my ($self, $link, $to) = @_;
  if (-e $link) {
    unlink($link) or barf "Couldn't unlink ${link}: $!";
  }
  symlink($to, $link)
    or barf "Couldn't link ${link} to ${to}: $!";
}

sub run_config_perl_set {
  my ($self, $new_perl) = @_;
  barf "plx --config perl set <perl>" unless $new_perl;
  my $perl_spec = $new_perl;
  unless ($new_perl =~ m{/}) {
    $new_perl = "perl-${new_perl}" if $new_perl =~ /^5/;
    require File::Which;
    stderr "Resolving perl '${new_perl}' via PATH";
    if (my $resolved = File::Which::which($new_perl)) {
      $new_perl = $resolved;
    } else {
      stderr "Resolving perl '${new_perl}' via perlbrew";
      local %ENV = our %orig_env;
      barf "Couldn't find perlbrew in \$PATH"
        unless my $perlbrew = File::Which::which('perlbrew');
      my @list = $self->slurp_command($perlbrew, 'list');
      barf join(
        '', "No such perlbrew perl '${new_perl}', choose from:\n\n", @list
      ) unless grep $_ eq $new_perl, map /(\S+)/, @list;
      ($new_perl) = $self->slurp_command(
        $perlbrew, qw(exec --with), $new_perl, qw(perl -e), 'print $^X'
      );
      chomp $new_perl;
    }
  }
  barf "Not executable: $new_perl" unless -x $new_perl;
  $self->ensure_conf_dir;
  my $perl_link = $fs->catfile($self->layout_conf_dir, 'perl');
  $self->ensure_link($perl_link, $new_perl);
  my $spec_link = $fs->catfile($self->layout_conf_dir, 'perl.spec');
  $self->ensure_link($spec_link, $perl_spec);
}

sub run_config_perl_clear {
  return unless my $conf_dir = $self->layout_conf_dir;
  return unless -e (my $perl_link = $fs->catfile($conf_dir, 'perl'));
  unlink($perl_link) or barf "Couldn't unlink ${perl_link}: $!";
}

sub run_config_libspec_show {
  my @ent = @{$self->layout_libspec_config};
  my $max = List::Util::max(map length($_->[0]), @ent);
  say sprintf("%-${max}s  %s", @$_) for @ent;
}

sub run_config_libspec_add {
  my ($self, $name, $path) = @_;
  barf "plx --config libspec add <name> <path>" unless $name and $path;
  my $link = $fs->catfile($self->layout_libspec_dir, $name);
  $self->ensure_link($link, $path);
}

sub run_config_libspec_del {
  my ($self, $name) = @_;
  barf "plx --config libspec add <name>" unless $name;
  my $link = $fs->catfile($self->layout_libspec_dir, $name);
  if (-e $link) {
    unlink($link) or barf "Couldn't unlink ${link}: $!";
  }
}

sub show_env {
  my ($self, $env) = @_;
  local $ENV{$env} = '';
  $self->setup_env;
  say $_ for split ':', $ENV{$env};
}

sub run_action_libs { $self->show_env('PERL5LIB') }

sub run_action_paths { $self->show_env('PATH') }

sub run_action_help {
  require Pod::Usage;
  Pod::Usage::pod2usage();
}

sub run {
  my ($self, $cmd, @args) = @_;
  $self->run_action_help unless $cmd;
  if ($cmd =~ s/^--//) {
    my $method = join('_', 'run_action', split '-', $cmd);
    if (my $code = $self->can($method)) {
      return $self->$code(@args);
    }
    barf "No command for ${cmd}";
  }
  return $self->run_action_cmd($cmd, @args);
}

caller() ? 1 : __PACKAGE__->new->run(@ARGV);

__END__

=head1 NAME

plx - Perl Layout Executor

=head1 USAGE

  plx --help                             # This output

  plx --perl                             # Show perl binary
  plx --libs                             # Show $PERL5LIB entries
  plx --paths                            # Show additional $PATH entries

  plx --config perl                      # Show perl binary
  plx --config perl show                 # Show perl binary
  plx --config perl set /path/to/perl    # Select perl binary
  plx --config perl set perl-5.xx.y      # Select a perlbrew perl binary
  plx --config perl clear                # Revert to system perl

  plx --exec <cmd> <args>                # exec()s with env vars set
  plx --perl <args>                      # Run perl with args
  plx --bin <script> <args>              # Run script from bin/
  plx --dev <script> <args>              # Run script from dev/
  plx --cpanm <args>                     # Run fatpacked cpanm

  plx --cmd <cmd> <args>                 # DWIM command:
  
    cmd = perl           -> --perl <args>
    cmd = -<flag>        -> --perl -<flag> <args>
    cmd = some/file      -> --perl some/file <args>
    cmd = ./file         -> --perl ./file <args>
    cmd = name ->
      exists dev/<name>  -> --dev <name> <args>
      exists bin/<name>  -> --bin <name> <args>
      else               -> --exec <name> <args>
  
  plx <something> <args>                 # equivalent to --cmd so:
 
  plx perl <args>                        # runs perl
  plx -E '...'                           # runs perl 
  plx script-in-dev <args>               # runs script in dev/
  plx script-in-bin <args>               # runs script in bin/
  plx script/in/cwd <args>               # runs script in cwd
  plx program <args>                     # runs program from plx $PATH

=head1 ACTIONS

=head2 --help

Prints out the usage information (i.e. the L</SYNOPSIS>) for plx.

=head2 --perl

Without arguments: prints the perl binary that plx will use to execute things.

With arguments: Executes perl with those arguments.

=head2 --config perl set

If the argument contains a / character, it is assumed to be a perl binary
and C<plx> checks that it's executable then records it as the current perl.

If not, C<plx> attempts to resolve it as a L<perlbrew> binary name and if
successful records that binary as the current perl.

=head2 --config perl clear

Clears the C<plx> perl binary setting and reverts the config to whatever is
available in C<$PATH>.

=head2 --libs

Prints the directories that will be added to C<PERL5LIB>, one per line.

=head2 --paths

Prints the directories that will be added to C<PATH>, one per line.

=head2 --cpanm

Calls a per-C<plx>-config cpanm, which is fetched from miyagawa's github on
demand. Intended for bootstrapping or for minimising installed modules.

=head2 script

If C<plx> is passed a plain name and that exists as a filename within C<dev/>
or C<bin/> then the file will be called using C<perl>.

=head2 ./file

if C<plx> is passed a name containing a C</> character then that filename is
called using C<perl>.

=head2 command

If C<plx> is passed a name without a C</> character that does not exist as an
L</script> then it calls it as a normal command name, respecting the C<$PATH>
as set up by the layout.

=cut
